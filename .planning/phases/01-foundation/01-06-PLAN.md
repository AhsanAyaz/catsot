---
phase: 01-foundation
plan: 06
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-04"]
files_modified:
  - modules/06-logic-engine/README.md
  - modules/06-logic-engine/demonstration.md
  - modules/06-logic-engine/exercise.md
  - modules/06-logic-engine/starter-template/logic_engine.py
  - modules/06-logic-engine/starter-template/README.md
  - modules/06-logic-engine/solutions/solution.py
  - modules/06-logic-engine/solutions/README.md
autonomous: true

must_haves:
  truths:
    - "Starter template provides working logic engine foundation"
    - "Demonstration shows how to define and execute rules"
    - "Exercise guides participants through adding custom rules"
    - "Part 2 connection is explicitly stated (AI generates rules from natural language)"
  artifacts:
    - path: "modules/06-logic-engine/README.md"
      provides: "Module overview and Part 2 preview"
      min_lines: 25
    - path: "modules/06-logic-engine/starter-template/logic_engine.py"
      provides: "Working Python logic engine implementation"
      min_lines: 60
      contains: "class LogicEngine"
    - path: "modules/06-logic-engine/demonstration.md"
      provides: "Live coding demo guide for logic engine"
      min_lines: 40
    - path: "modules/06-logic-engine/solutions/solution.py"
      provides: "Complete solution with example rules"
      min_lines: 80
  key_links:
    - from: "modules/06-logic-engine/README.md"
      to: "Part 2 enhancement"
      via: "explains how AI will generate rules"
      pattern: "Part 2.*AI.*generate.*rules"
    - from: "modules/06-logic-engine/exercise.md"
      to: "starter-template/"
      via: "references provided code"
      pattern: "starter-template/"
---

<objective>
Create Module 06: Logic Engine Build - the capstone module where participants build a rule-based system that serves as the shared foundation for Part 2 projects.

Purpose: This module synthesizes all previous concepts (AI Studio, structured output, context engineering) into a practical build. The logic engine demonstrates business rules automation and sets up the "vibe code" pattern where Part 2 will use Gemini to generate rules from natural language.

Output: Complete module with pre-built logic engine starter template, demonstration showing rule definition and execution, hands-on exercise adding custom rules, and solutions showing Part 2 enhancement opportunities.
</objective>

<execution_context>
@/home/ahsan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ahsan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/ahsan/projects/code-at-speed-of-thought/.planning/PROJECT.md
@/home/ahsan/projects/code-at-speed-of-thought/.planning/ROADMAP.md
@/home/ahsan/projects/code-at-speed-of-thought/.planning/STATE.md
@/home/ahsan/projects/code-at-speed-of-thought/.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create Module 06 structure, README with Part 2 preview, and logic engine starter template</name>
  <files>
    modules/06-logic-engine/README.md
    modules/06-logic-engine/starter-template/logic_engine.py
    modules/06-logic-engine/starter-template/README.md
    modules/06-logic-engine/solutions/.gitkeep
  </files>
  <action>
Create module directory structure, README explaining the logic engine concept and Part 2 connection, and starter template with working logic engine code based on RESEARCH.md.

**README.md content:**
- Module title: "Module 06: Logic Engine - Foundations for AI-Powered Rules"
- Duration: 20 minutes
- Learning Objectives:
  * Understand rule-based systems (condition → action pattern)
  * Implement simple business rules in Python
  * Execute rules against context data
  * Envision how AI can generate rules from natural language (Part 2 preview)
- Prerequisites:
  * Completion of Module 01 (AI Studio basics)
  * Completion of Module 02 (Structured output - helpful for understanding rule format)
  * Basic Python knowledge (reading code, understanding functions and classes)
- Overview:
  * **What is a logic engine:** System that evaluates conditions and executes actions based on rules
  * **Why build this:** Foundation for Part 2 where Gemini will generate these rules from natural language
  * **The progression:**
    - Part 1 (this module): Manually define rules in code
    - Part 2: Use Gemini to generate rules from descriptions like "Give discount to customers who buy more than 10 items"
- Part 2 Connection (explicit):
  ```
  ### Part 2 Preview: AI-Generated Rules

  In Part 2, you'll enhance this logic engine by:
  1. Using Gemini to convert natural language → rule definitions
  2. Applying structured output (Module 02) to ensure valid rule format
  3. Building a UI in Firebase Studio to manage rules
  4. Deploying the logic engine as a Firebase function

  Example Part 2 flow:
  User input: "Apply 20% discount for premium members"
  Gemini output (structured):
  {
    "name": "Premium Member Discount",
    "condition": "membership_tier == 'premium'",
    "action": "apply_discount(20)"
  }
  Logic Engine: Executes the generated rule
  ```
- Reference to demonstration.md, exercise.md, and starter-template/

**starter-template/logic_engine.py content:**
Use the complete logic engine code from RESEARCH.md (Logic Engine Foundation section) with clear comments:

```python
"""
Simple Logic Engine for Workshop Module 06

This is the foundation for Part 2 where Gemini will generate rules from natural language.

Key Concepts:
- Rule: A condition + action pair
- Condition: A function that returns True/False when evaluated against context
- Action: A function that executes when condition is True
- Context: Dictionary of data to evaluate rules against
"""

from typing import List, Dict, Any, Callable
from dataclasses import dataclass

@dataclass
class Rule:
    """A single business rule"""
    name: str
    condition: Callable[[Dict[str, Any]], bool]  # Function that returns True/False
    action: Callable[[Dict[str, Any]], str]       # Function that executes if condition is True

class LogicEngine:
    """Simple rules engine for evaluating conditions and taking actions"""

    def __init__(self):
        self.rules: List[Rule] = []

    def add_rule(self, rule: Rule):
        """Add a rule to the engine"""
        self.rules.append(rule)

    def evaluate(self, context: Dict[str, Any]) -> List[str]:
        """
        Evaluate all rules against the context, return actions taken.

        Args:
            context: Dictionary with data to evaluate (e.g., {"quantity": 12, "user_type": "premium"})

        Returns:
            List of action results (strings describing what actions were taken)
        """
        actions_taken = []

        for rule in self.rules:
            try:
                if rule.condition(context):
                    result = rule.action(context)
                    actions_taken.append(f"{rule.name}: {result}")
            except Exception as e:
                actions_taken.append(f"{rule.name}: ERROR - {str(e)}")

        return actions_taken


# Example usage (workshop demonstration)
if __name__ == "__main__":
    # Create the engine
    engine = LogicEngine()

    # Define rules (Part 1: manually coded, Part 2: Gemini-generated)
    engine.add_rule(Rule(
        name="Bulk Discount",
        condition=lambda ctx: ctx.get("quantity", 0) >= 10,
        action=lambda ctx: "Applied 20% bulk discount"
    ))

    engine.add_rule(Rule(
        name="New Customer Welcome",
        condition=lambda ctx: ctx.get("is_new_customer", False),
        action=lambda ctx: "Applied 10% new customer discount"
    ))

    engine.add_rule(Rule(
        name="Premium Member Perk",
        condition=lambda ctx: ctx.get("membership_tier") == "premium",
        action=lambda ctx: "Applied 15% premium member discount"
    ))

    # Test the engine with different contexts
    print("Scenario 1: Premium member buying 12 items")
    context1 = {
        "quantity": 12,
        "is_new_customer": False,
        "membership_tier": "premium"
    }
    results1 = engine.evaluate(context1)
    print("Actions:", results1)
    # Expected: ['Bulk Discount: Applied 20% bulk discount', 'Premium Member Perk: Applied 15% premium member discount']

    print("\nScenario 2: New customer buying 5 items")
    context2 = {
        "quantity": 5,
        "is_new_customer": True,
        "membership_tier": "regular"
    }
    results2 = engine.evaluate(context2)
    print("Actions:", results2)
    # Expected: ['New Customer Welcome: Applied 10% new customer discount']

    print("\nScenario 3: Regular member buying 3 items")
    context3 = {
        "quantity": 3,
        "is_new_customer": False,
        "membership_tier": "regular"
    }
    results3 = engine.evaluate(context3)
    print("Actions:", results3)
    # Expected: [] (no rules matched)
```

**starter-template/README.md content:**

```markdown
# Logic Engine Starter Template

This is the foundation code for Module 06. It provides a working logic engine that you'll modify and extend.

## What This Does

The logic engine evaluates **rules** against **context** data.

- **Rule:** A condition (when to activate) + action (what to do)
- **Context:** Data to evaluate (e.g., user info, order details)
- **Evaluation:** Check all rules, execute actions for matching conditions

## How to Use

### 1. Run the example
```bash
python logic_engine.py
```

You should see:
```
Scenario 1: Premium member buying 12 items
Actions: ['Bulk Discount: Applied 20% bulk discount', 'Premium Member Perk: Applied 15% premium member discount']
...
```

### 2. Understand the structure

**Rule definition:**
```python
Rule(
    name="Bulk Discount",                          # Human-readable name
    condition=lambda ctx: ctx.get("quantity") >= 10,  # When to activate (returns True/False)
    action=lambda ctx: "Applied 20% bulk discount"    # What to do (returns string)
)
```

**Context (data to evaluate):**
```python
{
    "quantity": 12,
    "is_new_customer": False,
    "membership_tier": "premium"
}
```

**Evaluation:**
The engine checks each rule's condition. If True, it executes the action.

### 3. Your task (in exercise)

You'll add new rules for different business scenarios.

## Part 2 Preview

In Part 2, instead of writing rules manually, you'll use Gemini to generate them:

**Natural language input:**
"Give a discount to customers who buy more than 10 items"

**Gemini output (structured):**
```json
{
  "name": "Bulk Discount",
  "condition": "quantity >= 10",
  "action": "apply_discount(20)"
}
```

**Logic engine:** Converts JSON → Rule object and executes it

This is the "vibe code" pattern: describe what you want, AI generates the implementation.
```
  </action>
  <verify>
Verify all files exist:
```bash
ls -R modules/06-logic-engine/
```
Expected: README.md, starter-template/logic_engine.py, starter-template/README.md, solutions/.gitkeep

Verify logic engine code is complete:
```bash
cat modules/06-logic-engine/starter-template/logic_engine.py | grep -E "(class LogicEngine|def add_rule|def evaluate)" | wc -l
```
Expected: At least 3 matches

Verify Part 2 preview exists in README:
```bash
cat modules/06-logic-engine/README.md | grep -i "part 2" | wc -l
```
Expected: At least 3 mentions

Verify code runs without errors (syntax check):
```bash
python3 -m py_compile modules/06-logic-engine/starter-template/logic_engine.py && echo "Syntax valid"
```
Expected: "Syntax valid"
  </verify>
  <done>
Module 06 structure exists with README containing learning objectives and explicit Part 2 preview, starter template with complete working logic engine code from RESEARCH.md including example rules (bulk discount, new customer, premium member), and starter README explaining how to use the code.
  </done>
</task>

<task type="auto">
  <name>Create demonstration showing live coding of rule addition</name>
  <files>modules/06-logic-engine/demonstration.md</files>
  <action>
Create instructor demonstration guide showing how to work with the logic engine, emphasizing the Part 2 connection.

**Content structure (5-7 minute demonstration):**

**Introduction (1 minute):**
- The goal: Build a rule-based system as foundation for Part 2
- What you've learned so far:
  * Module 01: AI Studio basics
  * Module 02: Structured output (rules will be JSON)
  * Module 04: Context engineering (generating rules from natural language)
- This module: Manually build rules, Part 2: AI generates them

**Step-by-step demonstration (5-6 minutes):**

1. **Show the starter template structure**
   - Action: Open `starter-template/logic_engine.py` in editor
   - Walk through:
     * Rule dataclass (name, condition, action)
     * LogicEngine class (add_rule, evaluate methods)
     * Example rules at bottom
   - Point out: This is already working code, not pseudocode

2. **Run the example**
   - Action: Execute `python logic_engine.py`
   - Expected output:
     ```
     Scenario 1: Premium member buying 12 items
     Actions: ['Bulk Discount: Applied 20% bulk discount', 'Premium Member Perk: Applied 15% premium member discount']
     ```
   - Explain: Engine evaluated 3 rules, 2 matched the context

3. **Add a new rule live**
   - Action: Add a "Seasonal Sale" rule:
     ```python
     engine.add_rule(Rule(
         name="Summer Sale",
         condition=lambda ctx: ctx.get("month") == "June",
         action=lambda ctx: "Applied 30% summer sale discount"
     ))
     ```
   - Action: Update test context to include `"month": "June"`
   - Action: Re-run
   - Expected: "Summer Sale: Applied 30% summer sale discount" appears in results
   - Point out: Rules are composable and independent

4. **Show a complex condition**
   - Action: Add a rule with multiple conditions:
     ```python
     engine.add_rule(Rule(
         name="VIP Flash Sale",
         condition=lambda ctx: (
             ctx.get("membership_tier") == "vip" and
             ctx.get("quantity") >= 5 and
             ctx.get("month") in ["November", "December"]
         ),
         action=lambda ctx: "Applied 40% VIP holiday flash sale"
     ))
     ```
   - Point out: Conditions can be as complex as needed

5. **Preview Part 2 enhancement**
   - Action: Show how this would work in Part 2 (don't code, just explain):
     ```
     User types: "Give 30% discount in June"

     Part 2 flow:
     1. Send to Gemini with structured output (Module 02)
     2. Gemini returns JSON:
        {
          "name": "Summer Sale",
          "condition": "month == 'June'",
          "action": "apply_discount(30)"
        }
     3. Convert JSON to Rule object
     4. Add to engine
     5. Execute on customer data
     ```
   - Emphasize: Same logic engine, AI-generated rules instead of manual

6. **Visualize the flow**
   - Draw or describe:
     ```
     Part 1 (now):
     Developer writes rules → LogicEngine → Executes actions

     Part 2 (next):
     User describes rule → Gemini generates JSON → LogicEngine → Executes actions
     ```

**Key talking points:**
- **Foundation, not final product:** This is the shared base for Part 2 projects
- **Vibe coding:** Describe what you want, AI generates the implementation
- **Structured output enables this:** JSON Schema (Module 02) ensures valid rule format
- **Real business value:** Rule generation from natural language speeds up business logic changes
- **Part 2 options:** Face-reactive app, camera game, or custom project all build on this

**Timing note from RESEARCH.md:**
This module has a simplified approach:
- Pre-built code (not coded from scratch)
- Participants read + modify (not write from scratch)
- 5 min demo + 10 min exercise fits 20-minute window
  </action>
  <verify>
Verify demonstration.md contains required sections:

```bash
cat modules/06-logic-engine/demonstration.md | grep -E "(Step [0-9]:|Action:|Expected|Point out)" | wc -l
```
Expected: At least 15 matches

Verify Part 2 preview is included:
```bash
cat modules/06-logic-engine/demonstration.md | grep -i "part 2" | wc -l
```
Expected: At least 5 mentions

Verify vibe coding pattern is explained:
```bash
cat modules/06-logic-engine/demonstration.md | grep -i "vibe\|natural language.*generate" | wc -l
```
Expected: At least 2 mentions
  </verify>
  <done>
Demonstration guide exists with walkthrough showing starter template structure, running the example, adding a new rule live, showing complex multi-condition rule, and explicit Part 2 preview explaining how AI will generate rules from natural language using structured output from Module 02.
  </done>
</task>

<task type="auto">
  <name>Create hands-on exercise and complete solution with Part 2 enhancement ideas</name>
  <files>
    modules/06-logic-engine/exercise.md
    modules/06-logic-engine/solutions/solution.py
    modules/06-logic-engine/solutions/README.md
  </files>
  <action>
Create hands-on exercise where participants modify the logic engine and add custom rules.

**exercise.md content (10-13 minutes):**

**Your Task:**
Extend the logic engine with custom rules and design how Gemini would generate them in Part 2.

**Setup (1 minute):**
1. Download or copy `starter-template/logic_engine.py` to your local environment
2. Test that it runs: `python logic_engine.py`
3. Open in your code editor

**Option A: Guided Challenge (For beginners)**

**Challenge:** Add three new rules to the discount logic engine

Step 1: Add a "Seasonal Sale" rule (3 minutes)
- Locate the rule definitions in `logic_engine.py` (around line 50)
- Add a new rule:
  ```python
  engine.add_rule(Rule(
      name="Winter Sale",
      condition=lambda ctx: ctx.get("month") in ["December", "January", "February"],
      action=lambda ctx: "Applied 25% winter sale discount"
  ))
  ```
- Update the test context to include `"month": "January"`
- Run and verify the rule triggers
- Success criteria: You see "Winter Sale: Applied 25% winter sale discount" in output

Step 2: Add a "High Value Order" rule (3 minutes)
- Add a rule that triggers when order total > $500:
  ```python
  engine.add_rule(Rule(
      name="High Value Order Bonus",
      condition=lambda ctx: ctx.get("order_total", 0) > 500,
      action=lambda ctx: f"Applied $50 bonus credit (order total: ${ctx.get('order_total')})"
  ))
  ```
- Test with context: `{"order_total": 600, ...}`
- Success criteria: Rule triggers and shows order total in action message

Step 3: Add a "Loyalty Points" rule (3 minutes)
- Add a rule with multiple conditions:
  ```python
  engine.add_rule(Rule(
      name="Loyalty Points Bonus",
      condition=lambda ctx: (
          ctx.get("loyalty_points", 0) > 1000 and
          ctx.get("membership_tier") in ["premium", "vip"]
      ),
      action=lambda ctx: f"Added 500 bonus loyalty points (current: {ctx.get('loyalty_points')})"
  ))
  ```
- Test with appropriate context
- Success criteria: Multi-condition rule works correctly

Step 4: Design Part 2 enhancement (2 minutes)
- For one of your rules, write how a user would describe it in natural language
- Example:
  * Rule: Winter Sale
  * Natural language: "Apply 25% discount during winter months (December, January, February)"
  * Think about: How would Gemini convert this to the JSON format from Module 02?

**Option B: Independent Challenge (For advanced users)**

Goal: Create a logic engine for a different domain (not discounts) and design the Part 2 AI enhancement.

Domain ideas:
- **Email routing:** Route emails to departments based on keywords, sender, urgency
- **Task prioritization:** Assign priority based on deadline, requester, project
- **Content moderation:** Flag content based on keywords, sentiment, length
- **Workflow automation:** Trigger actions based on form data, user roles, time

Requirements:
- Define at least 4 rules for your domain
- Include at least one multi-condition rule
- Test with 3 different contexts
- Write natural language descriptions for each rule (Part 2 preview)
- (Bonus) Design the JSON schema that Gemini would use to generate rules

Solution: See `solutions/` for reference

**For Fast Finishers: Going Further**

Advanced challenges:
- Add error handling (what if context is missing expected fields?)
- Create a `remove_rule` method for the LogicEngine class
- Design a JSON schema for rule definitions (Module 02 skills)
- Write a function that converts JSON rule → Rule object (Part 2 preview)
- Think about rule conflicts: what if two rules contradict?

**Success Criteria:**
- [ ] You have added at least 3 new rules to the logic engine
- [ ] You understand the Rule structure (name, condition, action)
- [ ] You have tested rules with different contexts
- [ ] You can envision how AI would generate rules from natural language
- [ ] You understand this is the foundation for Part 2 projects

Duration: ⏱️ Expected: 11 minutes | Buffer: 3 minutes

**solutions/solution.py content:**

```python
"""
Module 06 Solution - Extended Logic Engine

This solution includes:
- Original example rules (bulk discount, new customer, premium member)
- Three additional rules from the exercise
- Part 2 preview: JSON rule definitions
"""

from typing import List, Dict, Any, Callable
from dataclasses import dataclass

@dataclass
class Rule:
    """A single business rule"""
    name: str
    condition: Callable[[Dict[str, Any]], bool]
    action: Callable[[Dict[str, Any]], str]

class LogicEngine:
    """Simple rules engine for evaluating conditions and taking actions"""

    def __init__(self):
        self.rules: List[Rule] = []

    def add_rule(self, rule: Rule):
        """Add a rule to the engine"""
        self.rules.append(rule)

    def remove_rule(self, name: str):
        """Remove a rule by name"""
        self.rules = [r for r in self.rules if r.name != name]

    def evaluate(self, context: Dict[str, Any]) -> List[str]:
        """Evaluate all rules against the context, return actions taken"""
        actions_taken = []

        for rule in self.rules:
            try:
                if rule.condition(context):
                    result = rule.action(context)
                    actions_taken.append(f"{rule.name}: {result}")
            except Exception as e:
                actions_taken.append(f"{rule.name}: ERROR - {str(e)}")

        return actions_taken


if __name__ == "__main__":
    engine = LogicEngine()

    # Original rules
    engine.add_rule(Rule(
        name="Bulk Discount",
        condition=lambda ctx: ctx.get("quantity", 0) >= 10,
        action=lambda ctx: "Applied 20% bulk discount"
    ))

    engine.add_rule(Rule(
        name="New Customer Welcome",
        condition=lambda ctx: ctx.get("is_new_customer", False),
        action=lambda ctx: "Applied 10% new customer discount"
    ))

    engine.add_rule(Rule(
        name="Premium Member Perk",
        condition=lambda ctx: ctx.get("membership_tier") == "premium",
        action=lambda ctx: "Applied 15% premium member discount"
    ))

    # Exercise rules
    engine.add_rule(Rule(
        name="Winter Sale",
        condition=lambda ctx: ctx.get("month") in ["December", "January", "February"],
        action=lambda ctx: "Applied 25% winter sale discount"
    ))

    engine.add_rule(Rule(
        name="High Value Order Bonus",
        condition=lambda ctx: ctx.get("order_total", 0) > 500,
        action=lambda ctx: f"Applied $50 bonus credit (order total: ${ctx.get('order_total')})"
    ))

    engine.add_rule(Rule(
        name="Loyalty Points Bonus",
        condition=lambda ctx: (
            ctx.get("loyalty_points", 0) > 1000 and
            ctx.get("membership_tier") in ["premium", "vip"]
        ),
        action=lambda ctx: f"Added 500 bonus loyalty points (current: {ctx.get('loyalty_points')})"
    ))

    # Comprehensive test scenario
    print("="*60)
    print("Comprehensive Scenario: VIP member, winter purchase, high value")
    print("="*60)
    context = {
        "quantity": 15,
        "is_new_customer": False,
        "membership_tier": "vip",
        "month": "January",
        "order_total": 650,
        "loyalty_points": 1500
    }

    print(f"\nContext: {context}\n")
    results = engine.evaluate(context)

    print("Actions taken:")
    for action in results:
        print(f"  ✓ {action}")

    # Expected output:
    # ✓ Bulk Discount: Applied 20% bulk discount
    # ✓ Premium Member Perk: Applied 15% premium member discount (VIP is premium+)
    # ✓ Winter Sale: Applied 25% winter sale discount
    # ✓ High Value Order Bonus: Applied $50 bonus credit (order total: $650)
    # ✓ Loyalty Points Bonus: Added 500 bonus loyalty points (current: 1500)

    print("\n" + "="*60)
    print("Part 2 Preview: JSON Rule Definitions")
    print("="*60)
    print("""
In Part 2, Gemini would generate rules like this:

User input: "Give 25% discount during winter months"

Gemini output (using Module 02 structured output):
{
  "name": "Winter Sale",
  "condition": "month in ['December', 'January', 'February']",
  "action": "apply_discount(25)",
  "description": "Seasonal discount for winter purchases"
}

Then the system would:
1. Parse the JSON
2. Convert condition string to lambda function
3. Convert action string to lambda function
4. Create Rule object
5. Add to engine

This is the 'vibe code' pattern:
- Describe what you want in natural language
- AI generates the implementation
- System executes it
    """)
```

**solutions/README.md content:**

```markdown
# Module 06 Solution

This solution demonstrates the complete logic engine with all exercise rules plus Part 2 enhancement design.

## Running the Solution

```bash
python solution.py
```

## What's Included

### Original Rules (from starter template)
1. **Bulk Discount**: quantity >= 10 → 20% discount
2. **New Customer Welcome**: is_new_customer == true → 10% discount
3. **Premium Member Perk**: membership_tier == "premium" → 15% discount

### Exercise Rules (added)
1. **Winter Sale**: month in [Dec, Jan, Feb] → 25% discount
2. **High Value Order Bonus**: order_total > $500 → $50 credit
3. **Loyalty Points Bonus**: loyalty_points > 1000 AND membership premium/vip → 500 bonus points

### Enhancements
- Added `remove_rule` method to LogicEngine
- Comprehensive test scenario (triggers 5 rules simultaneously)
- Part 2 preview showing JSON rule format

## Part 2 Enhancement Design

### Natural Language → JSON → Rule

**Step 1: User describes rule in natural language**
```
"Apply 25% discount during winter months (December, January, February)"
```

**Step 2: Gemini generates JSON (using Module 02 structured output)**

JSON Schema:
```json
{
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "Human-readable rule name"
    },
    "condition": {
      "type": "string",
      "description": "Python expression that evaluates to True/False"
    },
    "action": {
      "type": "string",
      "description": "Function call or string to return when condition is True"
    },
    "description": {
      "type": "string",
      "description": "Explanation of what this rule does"
    }
  },
  "required": ["name", "condition", "action"]
}
```

Gemini output:
```json
{
  "name": "Winter Sale",
  "condition": "month in ['December', 'January', 'February']",
  "action": "apply_discount(25)",
  "description": "Seasonal 25% discount for winter purchases"
}
```

**Step 3: Convert JSON to Rule object**

```python
def json_to_rule(rule_json: dict) -> Rule:
    """Convert JSON rule definition to Rule object"""
    # Parse condition string to lambda
    condition_code = f"lambda ctx: {rule_json['condition']}"
    condition_fn = eval(condition_code)

    # Parse action string to lambda
    action_code = f"lambda ctx: '{rule_json['action']}'"
    action_fn = eval(action_code)

    return Rule(
        name=rule_json["name"],
        condition=condition_fn,
        action=action_fn
    )

# Usage in Part 2
rule_json = gemini_generate_rule("Apply 25% discount in winter")
rule = json_to_rule(rule_json)
engine.add_rule(rule)
```

## Real-World Part 2 Applications

### 1. Face-Reactive Experience (PATH-01)
- **Natural language rule:** "When user is smiling, show happy particles"
- **Generated rule:**
  ```json
  {
    "name": "Happy Emotion Trigger",
    "condition": "facial_expression == 'smile' and confidence > 0.7",
    "action": "spawn_particles('happy', color='yellow')"
  }
  ```

### 2. Camera-Based Game (PATH-02)
- **Natural language rule:** "Award bonus points if player captures QR code within 10 seconds"
- **Generated rule:**
  ```json
  {
    "name": "Speed Bonus",
    "condition": "qr_captured and time_elapsed < 10",
    "action": "add_points(50, reason='speed_bonus')"
  }
  ```

### 3. Custom Project
- **Natural language rule:** "Flag social media post if it contains negative sentiment and mentions brand"
- **Generated rule:**
  ```json
  {
    "name": "Brand Mention Alert",
    "condition": "sentiment == 'negative' and 'BrandName' in text",
    "action": "create_alert(priority='high', reason='negative_brand_mention')"
  }
  ```

## Key Learnings

- **Logic engines are simple but powerful:** Condition + action pattern handles many use cases
- **AI-generated rules unlock speed:** Business users can create rules without coding
- **Structured output enables reliability:** JSON Schema ensures valid rule format
- **Foundation for Part 2:** This engine is the shared base, Part 2 adds AI generation layer

## Further Exploration

- **Rule persistence:** Save rules to database (Firebase Firestore in Part 2)
- **Rule conflicts:** What if two rules contradict? Priority system needed
- **Rule testing:** How to validate rules before deploying?
- **Rule analytics:** Track which rules fire most often
- **Security:** Validate generated conditions to prevent code injection
```
  </action>
  <verify>
Verify all files exist:

```bash
ls -R modules/06-logic-engine/solutions/
```
Expected: solution.py, README.md

Verify solution code is complete:
```bash
cat modules/06-logic-engine/solutions/solution.py | grep -E "(engine.add_rule|def json_to_rule)" | wc -l
```
Expected: At least 6 (6 add_rule calls)

Verify Part 2 enhancement is explained:
```bash
cat modules/06-logic-engine/solutions/README.md | grep -i "part 2\|json.*rule\|natural language" | wc -l
```
Expected: At least 10 mentions

Verify solution runs without errors (syntax check):
```bash
python3 -m py_compile modules/06-logic-engine/solutions/solution.py && echo "Syntax valid"
```
Expected: "Syntax valid"
  </verify>
  <done>
Exercise file exists with guided challenge adding three new rules (winter sale, high value order, loyalty points), independent option for different domains, and Going Further section. Solution includes complete working code with 6 rules total, comprehensive test scenario, Part 2 enhancement design with JSON schema and conversion function, and real-world applications for all three Part 2 project paths.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify directory structure:
   ```bash
   ls -R modules/06-logic-engine/
   ```
   Expected: README.md, demonstration.md, exercise.md, starter-template/logic_engine.py, starter-template/README.md, solutions/solution.py, solutions/README.md

2. Verify code runs:
   ```bash
   cd modules/06-logic-engine/starter-template && python3 logic_engine.py
   ```
   Expected: Output showing rule evaluations

3. Verify Part 2 connection is explicit:
   ```bash
   grep -ri "part 2" modules/06-logic-engine/ | wc -l
   ```
   Expected: At least 15 mentions across all files

4. Verify vibe coding pattern is explained:
   ```bash
   grep -ri "vibe\|natural language.*generate\|describe.*AI.*implement" modules/06-logic-engine/ | wc -l
   ```
   Expected: At least 5 mentions
</verification>

<success_criteria>
Module 06 is complete when:
- [ ] All module files exist with proper structure
- [ ] Starter template provides working logic engine with 3 example rules
- [ ] Demonstration shows live coding of rule addition
- [ ] Exercise guides participants through adding 3 custom rules
- [ ] Solutions include complete working code with 6 total rules
- [ ] Part 2 connection is explicitly stated in multiple places
- [ ] JSON rule format and conversion pattern is demonstrated
- [ ] Real-world applications for all three Part 2 paths are shown
- [ ] Vibe coding pattern is clearly explained
- [ ] Duration fits 20-minute target
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-06-SUMMARY.md`
</output>
