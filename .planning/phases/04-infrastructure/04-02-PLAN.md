---
phase: 04-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - modules/01-ai-studio/solutions/gemini-client.js
  - modules/02-structured-output/solutions/structured-client.js
  - modules/03-multimodal/solutions/multimodal-client.js
  - modules/06-logic-engine/solutions/logic_engine_ai.py
  - part2/face-reactive/reference/src/geminiIntegration.js
  - infrastructure/quota-monitor.js
  - infrastructure/api-keys.env.example
  - infrastructure/README.md
autonomous: true

must_haves:
  truths:
    - "Multiple Gemini API keys are configured with automatic rotation"
    - "API calls automatically retry with backup keys on quota errors (429)"
    - "Quota monitoring dashboard shows real-time usage across all keys"
    - "Workshop can handle 40 participants without quota exhaustion"
  artifacts:
    - path: "infrastructure/quota-monitor.js"
      provides: "Round-robin API key rotation with quota tracking"
      min_lines: 100
      exports: ["QuotaAwareAPI"]
    - path: "infrastructure/api-keys.env.example"
      provides: "Template for multiple API key configuration"
      contains: "GEMINI_KEY_1"
    - path: "modules/01-ai-studio/solutions/gemini-client.js"
      provides: "Updated client using QuotaAwareAPI"
      contains: "QuotaAwareAPI"
  key_links:
    - from: "modules/*/solutions/*.js"
      to: "infrastructure/quota-monitor.js"
      via: "import QuotaAwareAPI"
      pattern: "import.*QuotaAwareAPI"
    - from: "infrastructure/quota-monitor.js"
      to: "process.env.GEMINI_KEY_*"
      via: "environment variable access"
      pattern: "process\\.env\\.GEMINI_KEY"
---

<objective>
Implement multi-key API quota monitoring and automatic failover to prevent workshop disruptions from Gemini API rate limits.

Purpose: With 40 participants hitting the Gemini API simultaneously, a single API key will exhaust quota quickly (free tier: 15 RPM). Multiple keys with round-robin rotation ensure continuous availability throughout the 3.5-hour workshop.

Output: QuotaAwareAPI wrapper class for automatic key rotation, updated solution code using the wrapper, and monitoring dashboard showing real-time usage.
</objective>

<execution_context>
@/home/ahsan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ahsan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/ahsan/projects/code-at-speed-of-thought/.planning/PROJECT.md
@/home/ahsan/projects/code-at-speed-of-thought/.planning/ROADMAP.md
@/home/ahsan/projects/code-at-speed-of-thought/.planning/STATE.md
@/home/ahsan/projects/code-at-speed-of-thought/.planning/phases/04-infrastructure/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create QuotaAwareAPI wrapper with round-robin failover</name>
  <files>
    infrastructure/quota-monitor.js
    infrastructure/README.md
  </files>
  <action>
Create infrastructure/quota-monitor.js implementing the pattern from 04-RESEARCH.md with enhancements for workshop context.

QuotaAwareAPI class structure:
```javascript
// infrastructure/quota-monitor.js
// Multi-key Gemini API wrapper with automatic quota failover

export class QuotaAwareAPI {
  constructor(keys, options = {}) {
    this.keys = keys.filter(k => k); // Remove empty keys
    this.currentIndex = 0;
    this.requestCounts = new Array(this.keys.length).fill(0);
    this.errorCounts = new Array(this.keys.length).fill(0);
    this.lastReset = Date.now();
    this.resetInterval = options.resetInterval || 60000; // 1 min
    this.maxRetries = options.maxRetries || this.keys.length;
    this.verbose = options.verbose || false;
  }

  async call(endpoint, options) {
    let attempts = 0;
    const startIndex = this.currentIndex;

    while (attempts < this.maxRetries) {
      const key = this.keys[this.currentIndex];
      const keyLabel = `Key ${this.currentIndex + 1}/${this.keys.length}`;

      try {
        const response = await fetch(endpoint, {
          ...options,
          headers: {
            ...options.headers,
            'x-goog-api-key': key // Gemini uses x-goog-api-key header
          }
        });

        // Handle quota exhaustion (429 Too Many Requests)
        if (response.status === 429) {
          this.errorCounts[this.currentIndex]++;
          if (this.verbose) console.warn(`‚ö†Ô∏è  ${keyLabel} quota exceeded, rotating...`);
          this.rotateKey();
          attempts++;
          await this.backoff(attempts); // Exponential backoff
          continue;
        }

        // Success - increment counter and return
        this.requestCounts[this.currentIndex]++;
        if (this.verbose) console.log(`‚úÖ ${keyLabel} request successful`);
        return response;

      } catch (error) {
        this.errorCounts[this.currentIndex]++;
        console.error(`‚ùå ${keyLabel} request failed:`, error.message);
        this.rotateKey();
        attempts++;
        await this.backoff(attempts);
      }
    }

    throw new Error(`All ${this.keys.length} API keys exhausted or failed after ${attempts} attempts`);
  }

  rotateKey() {
    this.currentIndex = (this.currentIndex + 1) % this.keys.length;
  }

  async backoff(attempt) {
    // Exponential backoff: 100ms, 200ms, 400ms, 800ms...
    const delay = Math.min(100 * Math.pow(2, attempt - 1), 2000);
    await new Promise(resolve => setTimeout(resolve, delay));
  }

  getStats() {
    const totalRequests = this.requestCounts.reduce((a, b) => a + b, 0);
    const totalErrors = this.errorCounts.reduce((a, b) => a + b, 0);
    return {
      currentKey: this.currentIndex + 1,
      totalKeys: this.keys.length,
      requestCounts: this.requestCounts,
      errorCounts: this.errorCounts,
      totalRequests,
      totalErrors,
      successRate: totalRequests > 0 ? ((totalRequests - totalErrors) / totalRequests * 100).toFixed(1) + '%' : 'N/A',
      uptime: Math.floor((Date.now() - this.lastReset) / 1000) + 's'
    };
  }

  printStats() {
    const stats = this.getStats();
    console.log('\nüìä API Quota Stats:');
    console.log(`   Current: Key ${stats.currentKey}/${stats.totalKeys}`);
    console.log(`   Total Requests: ${stats.totalRequests}`);
    console.log(`   Total Errors: ${stats.totalErrors}`);
    console.log(`   Success Rate: ${stats.successRate}`);
    console.log(`   Uptime: ${stats.uptime}`);
    stats.requestCounts.forEach((count, i) => {
      console.log(`   Key ${i + 1}: ${count} requests, ${stats.errorCounts[i]} errors`);
    });
  }
}
```

Add infrastructure/README.md documenting:
- Purpose (prevent workshop quota exhaustion)
- Setup (environment variables GEMINI_KEY_1, GEMINI_KEY_2, GEMINI_KEY_3)
- Usage (import QuotaAwareAPI, create instance, call API)
- Monitoring (getStats(), printStats() methods)
- Workshop context (40 participants, 3.5 hours, estimated 500-1000 API calls)

Include usage example with Gemini API:
```javascript
import { QuotaAwareAPI } from './infrastructure/quota-monitor.js';

const apiKeys = [
  process.env.GEMINI_KEY_1,
  process.env.GEMINI_KEY_2,
  process.env.GEMINI_KEY_3
].filter(Boolean);

const geminiAPI = new QuotaAwareAPI(apiKeys, { verbose: true });

const response = await geminiAPI.call(
  'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: [{ parts: [{ text: 'Tell me about Stockholm' }] }]
    })
  }
);

const result = await response.json();
console.log(result.candidates[0].content.parts[0].text);
geminiAPI.printStats();
```
  </action>
  <verify>
cat infrastructure/quota-monitor.js shows QuotaAwareAPI class with constructor, call(), rotateKey(), backoff(), getStats(), and printStats() methods. cat infrastructure/README.md documents setup and usage.
  </verify>
  <done>
QuotaAwareAPI class exists with automatic key rotation, exponential backoff, and quota monitoring dashboard functionality.
  </done>
</task>

<task type="auto">
  <name>Update solution code to use QuotaAwareAPI</name>
  <files>
    modules/01-ai-studio/solutions/gemini-client.js
    modules/02-structured-output/solutions/structured-client.js
    modules/03-multimodal/solutions/multimodal-client.js
    modules/06-logic-engine/solutions/logic_engine_ai.py
    part2/face-reactive/reference/src/geminiIntegration.js
  </files>
  <action>
Update all solution files that call Gemini API to use QuotaAwareAPI wrapper instead of direct fetch calls.

For JavaScript files (modules 01, 02, 03, part2/face-reactive):

1. Add import at top:
```javascript
import { QuotaAwareAPI } from '../../../infrastructure/quota-monitor.js'; // Adjust path as needed
```

2. Initialize API wrapper:
```javascript
const apiKeys = [
  process.env.GEMINI_KEY_1,
  process.env.GEMINI_KEY_2,
  process.env.GEMINI_KEY_3
].filter(Boolean);

if (apiKeys.length === 0) {
  console.warn('‚ö†Ô∏è  No GEMINI_KEY_* environment variables found. Using single key from GEMINI_API_KEY.');
  apiKeys.push(process.env.GEMINI_API_KEY);
}

const geminiAPI = new QuotaAwareAPI(apiKeys, { verbose: false }); // Set verbose: true for debugging
```

3. Replace fetch calls with geminiAPI.call():
```javascript
// Before:
const response = await fetch(endpoint, { method: 'POST', headers: {...}, body: {...} });

// After:
const response = await geminiAPI.call(endpoint, { method: 'POST', headers: {...}, body: {...} });
```

4. Add periodic stats logging (every 10 requests):
```javascript
if (requestCount % 10 === 0) {
  geminiAPI.printStats();
}
```

For Python file (modules/06-logic-engine/solutions/logic_engine_ai.py):
Create simplified Python version of round-robin pattern (no need for full QuotaAwareAPI port):
```python
import os
import requests
import time

GEMINI_KEYS = [
    os.getenv('GEMINI_KEY_1'),
    os.getenv('GEMINI_KEY_2'),
    os.getenv('GEMINI_KEY_3')
]
GEMINI_KEYS = [k for k in GEMINI_KEYS if k]  # Filter empty
current_key_index = 0

def call_gemini_with_fallback(prompt):
    global current_key_index
    attempts = 0
    while attempts < len(GEMINI_KEYS):
        key = GEMINI_KEYS[current_key_index]
        try:
            response = requests.post(
                'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',
                headers={'x-goog-api-key': key, 'Content-Type': 'application/json'},
                json={'contents': [{'parts': [{'text': prompt}]}]}
            )
            if response.status_code == 429:  # Quota exceeded
                print(f'‚ö†Ô∏è  Key {current_key_index + 1} quota exceeded, rotating...')
                current_key_index = (current_key_index + 1) % len(GEMINI_KEYS)
                attempts += 1
                time.sleep(0.1 * (2 ** attempts))  # Exponential backoff
                continue
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f'‚ùå Key {current_key_index + 1} failed: {e}')
            current_key_index = (current_key_index + 1) % len(GEMINI_KEYS)
            attempts += 1
    raise Exception(f'All {len(GEMINI_KEYS)} API keys exhausted')
```

Add comments explaining why QuotaAwareAPI is necessary (40 participants, quota limits, automatic failover).
  </action>
  <verify>
grep -r "QuotaAwareAPI" modules/*/solutions/*.js shows import statements in all JavaScript solution files. grep "call_gemini_with_fallback" modules/06-logic-engine/solutions/logic_engine_ai.py shows Python fallback implementation. grep -r "printStats" modules/*/solutions/*.js shows periodic monitoring calls.
  </verify>
  <done>
All solution code updated to use multi-key API pattern. Workshop participants can copy this pattern for production resilience.
  </done>
</task>

<task type="auto">
  <name>Create API key configuration template and documentation</name>
  <files>
    infrastructure/api-keys.env.example
    infrastructure/SETUP.md
  </files>
  <action>
Create environment variable template for workshop facilitator setup.

infrastructure/api-keys.env.example:
```bash
# Gemini API Keys for Workshop
# Copy this file to .env and fill in your keys
# Get keys from: https://aistudio.google.com/app/apikey

# Primary key (required)
GEMINI_API_KEY=your-primary-key-here
GEMINI_KEY_1=your-primary-key-here  # Same as above for consistency

# Backup keys (recommended for 40-person workshop)
GEMINI_KEY_2=your-backup-key-2-here
GEMINI_KEY_3=your-backup-key-3-here

# Optional: Additional keys for larger workshops
# GEMINI_KEY_4=your-backup-key-4-here
# GEMINI_KEY_5=your-backup-key-5-here

# Quota Estimation for 40 participants, 3.5 hours:
# - Free tier: 15 requests/min/key = 900 requests/hour/key
# - 3 keys = 2700 requests/hour total capacity
# - Workshop needs: ~500-800 requests total (estimated)
# - Safety margin: 3x capacity ensures no disruptions

# Google-sponsored API access: Contact workshop organizer
# May have higher quotas than free tier (verify before workshop)
```

infrastructure/SETUP.md:
```markdown
# Workshop Infrastructure Setup

## API Key Configuration

### Get API Keys

1. Visit [Google AI Studio](https://aistudio.google.com/app/apikey)
2. Create 3 API keys (click "Create API key" 3 times)
3. Copy keys to `infrastructure/api-keys.env` (rename from `.env.example`)

### Google-Sponsored Access

This workshop mentions "Google-sponsored API access" in PROJECT.md.
Contact the workshop organizer (Google Stockholm) to:
- Confirm quota limits for sponsored keys
- Verify if higher than free tier (15 RPM, 1500 RPD)
- Get instructions for using sponsored project/keys

### Load Environment Variables

**Node.js:**
```bash
npm install dotenv
```
```javascript
import dotenv from 'dotenv';
dotenv.config({ path: 'infrastructure/api-keys.env' });
```

**Python:**
```bash
pip install python-dotenv
```
```python
from dotenv import load_dotenv
load_dotenv('infrastructure/api-keys.env')
```

### Verify Setup

Run quota monitor test:
```bash
node infrastructure/test-quota-monitor.js
```

Expected output:
```
‚úÖ Key 1/3 request successful
‚úÖ Key 2/3 request successful
‚úÖ Key 3/3 request successful
üìä API Quota Stats:
   Current: Key 1/3
   Total Requests: 3
   Success Rate: 100%
```

## Quota Monitoring During Workshop

### Real-Time Dashboard

Google Cloud Console ‚Üí IAM & Admin ‚Üí Quotas:
- Filter: "Gemini API"
- Monitor: Requests per minute, requests per day
- Alert: Set up quota alerts at 80% threshold

### Client-Side Monitoring

Use `geminiAPI.printStats()` every 10 requests to track:
- Current active key
- Request distribution across keys
- Error rates and success rates
- Uptime

### Troubleshooting

**All keys exhausted:**
- Wait 1 minute for quota reset (15 RPM = resets every minute)
- Switch to offline mock (backup/mocks/gemini-api-mock.js)
- Ask participants to slow down, work on non-API tasks

**Single key failing:**
- Rotation happens automatically
- Check error message for invalid key, billing issues
- Verify key is not restricted to specific IPs/referrers

**High error rate (>10%):**
- Check network connectivity
- Verify API endpoint URL is correct
- Check for model name changes (gemini-2.0-flash may be renamed)
```
  </action>
  <verify>
cat infrastructure/api-keys.env.example shows template with 3 keys and quota estimation comments. cat infrastructure/SETUP.md documents API key setup, Google-sponsored access, environment loading, and troubleshooting.
  </verify>
  <done>
API key configuration template and setup documentation complete. Workshop facilitator has clear instructions for multi-key setup and quota monitoring.
  </done>
</task>

</tasks>

<verification>
Test quota monitoring system:
1. Create test script that makes 50 rapid API calls
2. Configure with 2 keys (easier to test rotation)
3. Run script and verify automatic rotation on 429 errors
4. Check printStats() output shows request distribution
5. Verify all keys are used (not stuck on one key)

Test environment variable loading:
1. Copy api-keys.env.example to .env
2. Add 3 test API keys
3. Import QuotaAwareAPI in test script
4. Verify all 3 keys are loaded (check stats.totalKeys === 3)
</verification>

<success_criteria>
- [ ] QuotaAwareAPI class implements round-robin rotation with exponential backoff
- [ ] All solution files updated to use QuotaAwareAPI wrapper
- [ ] api-keys.env.example template exists with quota estimation comments
- [ ] SETUP.md documents API key configuration and quota monitoring
- [ ] Quota monitoring shows real-time stats (current key, requests, errors, success rate)
- [ ] Workshop can handle 40 participants with 3 API keys (estimated 2700 req/hour capacity vs 500-800 needed)
</success_criteria>

<output>
After completion, create `.planning/phases/04-infrastructure/04-02-SUMMARY.md`
</output>
